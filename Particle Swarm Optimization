import numpy as np
import matplotlib.pyplot as plt

# Objective function
def objective_function(position):
    x, y = position
    return x**2 + y**2

# PSO Parameters
num_particles = 30
num_iterations = 100
w = 0.5       # inertia weight
c1 = 1.5      # cognitive coefficient
c2 = 1.5      # social coefficient

# Initialize particles' positions and velocities randomly
positions = np.random.uniform(-10, 10, (num_particles, 2))
velocities = np.random.uniform(-1, 1, (num_particles, 2))

# Initialize personal best positions and values
pbest_positions = positions.copy()
pbest_values = np.array([objective_function(p) for p in positions])

# Initialize global best position and value
gbest_index = np.argmin(pbest_values)
gbest_position = pbest_positions[gbest_index]
gbest_value = pbest_values[gbest_index]

# Store history for plotting
history = []

for t in range(num_iterations):
    for i in range(num_particles):
        r1, r2 = np.random.rand(2)

        # Update velocity
        velocities[i] = (
            w * velocities[i]
            + c1 * r1 * (pbest_positions[i] - positions[i])
            + c2 * r2 * (gbest_position - positions[i])
        )

        # Update position
        positions[i] = positions[i] + velocities[i]

        # Evaluate fitness
        fitness = objective_function(positions[i])

        # Update personal best if necessary
        if fitness < pbest_values[i]:
            pbest_positions[i] = positions[i].copy()
            pbest_values[i] = fitness

            # Update global best if necessary
            if fitness < gbest_value:
                gbest_position = positions[i].copy()
                gbest_value = fitness

    history.append(gbest_value)

print(f"Global best position: {gbest_position}")
print(f"Global best value: {gbest_value}")

# Plot convergence
plt.plot(history)
plt.xlabel('Iteration')
plt.ylabel('Best Fitness Value')
plt.title('PSO Convergence on F(x,y) = x^2 + y^2')
plt.show()
